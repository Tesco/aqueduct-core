package com.tesco.aqueduct.pipe.storage;

import com.opentable.db.postgres.embedded.EmbeddedPostgres;
import com.tesco.aqueduct.pipe.api.Message;
import com.tesco.aqueduct.pipe.api.MessageResults;
import groovy.sql.Sql;
import org.openjdk.jmh.annotations.*;

import javax.sql.DataSource;
import java.io.IOException;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.ZonedDateTime;
import java.util.*;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@Fork(value = 1)
@Measurement(iterations = 10, time = 30)
public class ReadEventsQueryBenchmark {

    @State(Scope.Benchmark)
    public static class PostgresDatabaseState {

        public static final int CLUSTER_COUNT = 100;
        public static final int TYPES_COUNT = 10;
        public static final String TYPE_PREFIX = "Type_";
        private EmbeddedPostgres pg;
        private PostgresqlStorage storage;
        private Sql sql;
        private DataSource dataSource;

        private static final long CLUSTER_A = 1L;

        private long retryAfter = 5000;
        private int limit = 20000;
        private long batchSize = 2000000;

        List<Long> clusterIds;

        List<String> types;

        Map<Long, String> clusterMap = new HashMap<>();

        @Setup(Level.Trial)
        public void doSetup() throws Exception {
            System.out.println("setUp invoked");

            setupDatabase();

            clusterIds = new ArrayList<>(CLUSTER_COUNT);
            types = new ArrayList<>(TYPES_COUNT);

            for (int i=0; i < TYPES_COUNT; i++) {
                types.add(typeName(i));
            }

            for (int i=0; i<CLUSTER_COUNT; i++) {
                String clusterUuid = "Cluster_" + i;
                Long clusterId = insertCluster(clusterUuid);
                clusterIds.add(clusterId);
                clusterMap.put(clusterId, clusterUuid);
            }

            for (long i=0; i<1000000; i++) {
                insertWithCluster(
                        message(i, randomType(), "key_" + i, "content-type", ZonedDateTime.parse("2000-12-01T10:00:00Z"), MESSAGE_CONTENT),
                        randomClusterId());
            }
        }

        private String typeName(int i) {
            return TYPE_PREFIX + i;
        }

        private Long randomClusterId() {
            return clusterIds.get(ThreadLocalRandom.current().nextInt(100));
        }

        private String randomType() {
            return types.get(ThreadLocalRandom.current().nextInt(10));
        }

        private String randomClusterUuid() {
            return clusterMap.get(randomClusterId());
        }

        @TearDown(Level.Trial)
        public void doTearDown() {
            System.out.println("teardown invoked");

            sql.close();
        }

        void setupDatabase() throws SQLException, IOException {
            pg = EmbeddedPostgres.start();

            dataSource = pg.getPostgresDatabase();

            sql = new Sql(dataSource.getConnection());

            sql.execute(
                    "DROP TABLE IF EXISTS EVENTS;" +
                            "DROP TABLE IF EXISTS CLUSTERS;" +
                            "CREATE TABLE EVENTS(" +
                            "    msg_offset bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY NOT NULL," +
                            "    msg_key varchar NOT NULL," +
                            "    content_type varchar NOT NULL," +
                            "    type varchar NOT NULL," +
                            "    created_utc timestamp NOT NULL," +
                            "    tags JSONB NULL," +
                            "    data text NULL," +
                            "    event_size int NOT NULL," +
                            "    cluster_id BIGINT NOT NULL DEFAULT 1" +
                            ");" +
                            "CREATE TABLE CLUSTERS(" +
                            "    cluster_id BIGSERIAL PRIMARY KEY NOT NULL," +
                            "    cluster_uuid VARCHAR NOT NULL" +
                            ");" +
                            "INSERT INTO CLUSTERS (cluster_uuid) VALUES ('NONE');" +
                            "CREATE INDEX type_idx ON EVENTS (type);" +
                            "CREATE INDEX key_idx ON EVENTS (msg_key);" +
                            "CREATE INDEX created_idx ON EVENTS (created_utc,msg_key);" +
                            "CREATE INDEX cluster_idx ON EVENTS (msg_key, cluster_id);"
            );

            storage = new PostgresqlStorage(this.dataSource, limit, retryAfter, batchSize);
        }

        void insertWithCluster(Message msg, Long clusterId) throws SQLException {
            Timestamp time = Timestamp.valueOf(msg.getCreated().toLocalDateTime());
            sql.execute(
                    "INSERT INTO EVENTS(msg_offset, msg_key, content_type, type, created_utc, data, event_size, cluster_id) VALUES(?,?,?,?,?,?,?,?);",
                    new Object[] {msg.getOffset(), msg.getKey(), msg.getContentType(), msg.getType(), time, msg.getData(), 0, clusterId});
        }

        Long insertCluster(String clusterUuid) throws SQLException {
            return (Long)sql.executeInsert("INSERT INTO CLUSTERS(cluster_uuid) VALUES (?);", new Object[] {clusterUuid}).get(0).get(0);
        }

        Message message(Long offset, String type, String key, String contentType, ZonedDateTime created, String data) {
            return new Message(
                    type,
                    key,
                    contentType,
                    offset,
                    created,
                    data
            );
        }
    }

    @Benchmark
    @BenchmarkMode(Mode.AverageTime) @OutputTimeUnit(TimeUnit.MILLISECONDS)
    public void eventsQuery(PostgresDatabaseState postgresDatabaseState) {
        System.out.println("Benchmark invoked");
        List<String> clusters = IntStream.range(0, ThreadLocalRandom.current().nextInt(10) + 1)
                .mapToObj(i -> postgresDatabaseState.randomClusterUuid()).collect(Collectors.toList());

        List<String> types = IntStream.range(0, ThreadLocalRandom.current().nextInt(PostgresDatabaseState.TYPES_COUNT) + 1)
                .mapToObj(postgresDatabaseState::typeName).collect(Collectors.toList());

        Collections.shuffle(clusters);
        Collections.shuffle(types);

        System.out.println("Cluster range: " + clusters);
        System.out.println("Types range: " + types);

        MessageResults messageResults = postgresDatabaseState.storage.read(types, 0, clusters);
        System.out.println("Results size: " + messageResults.getMessages().size());
    }

    private static final String MESSAGE_CONTENT = "{\n" +
            "  \"promotions\" : [\n" +
            "    {\n" +
            "      \"id\": \"A32187466\",\n" +
            "      \"bucketNumber\": \"790\",\n" +
            "      \"storeGroups\": [\n" +
            "        \"Z1\"\n" +
            "      ],\n" +
            "      \"startDateTime\": \"2017-04-19T00:00:00+00:00\",\n" +
            "      \"endDateTime\": \"2030-07-11T23:59:59+00:00\",\n" +
            "      \"name\": \"Save 20% on fuels and other products\",\n" +
            "      \"shortDescription\": \"Save 20% on fuels and other products\",\n" +
            "      \"condition\": {\n" +
            "        \"id\": \"1\",\n" +
            "        \"type\": \"productMatch\",\n" +
            "        \"productGtins\": [\n" +
            "          \"05050179865189\",\n" +
            "          \"00111122223333\"\n" +
            "        ],\n" +
            "        \"requiredQuantityMin\": \"1\",\n" +
            "        \"requiredQuantityMax\": \"1\",\n" +
            "        \"cheapest\": true\n" +
            "      },\n" +
            "      \"rewardRules\": [\n" +
            "        {\n" +
            "          \"applyTo\": {\n" +
            "            \"conditions\": [\n" +
            "              \"1\"\n" +
            "            ],\n" +
            "            \"cheapest\": true,\n" +
            "            \"maxQuantity\": \"1\"\n" +
            "          },\n" +
            "          \"type\": \"percentageDiscount\",\n" +
            "          \"percentageDiscount\": \"20\",\n" +
            "          \"addToTillRewards\" : true\n" +
            "        }\n" +
            "      ],\n" +
            "      \"type\": \"multi_buy_promotion\"\n" +
            "    }\n" +
            "  ],\n" +
            "  \"storeGroups\": [\n" +
            "    {\n" +
            "      \"id\": \"Z1\",\n" +
            "      \"storeNumbers\": [\n" +
            "        \"02065\"\n" +
            "      ]\n" +
            "    }\n" +
            "  ]\n" +
            "}";

}
